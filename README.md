# [기말고사] 최적화 알고리즘을 이용한 회귀식 추정
**201701685 윤동관 제출**

## 데이터 집합 선택
회귀식이란, 독립변수와 종속변수가 존재할 때, 종속변수로부터 오차가 가장 작은 직선의 방정식을 의미한다.

본 과제를 위해 독립변수와 종속변수의 데이터 집합을 고르는 과정에서, 지난 과제 중 정렬 알고리즘을 비교한 데이터가 있어 활용해보기로 하였다.

일반적으로 정렬 알고리즘의 소요 시간 그래프는 입력이 2의 17제곱부터 급격히 올라가는 형태이지만, Log2를 적용시킨 그래프는 선형적으로 표시되는 것을 확인했다.

### 버블정렬 그래프
![버블 로그x](https://user-images.githubusercontent.com/39906922/173866788-c7067a0a-5088-4e97-9223-5f08c3a285c9.png)

### 버블정렬 Log2 그래프
![버블 로그o](https://user-images.githubusercontent.com/39906922/173866873-cd70bc67-5963-4606-916a-59a22b90da3f.png)

### 정렬 알고리즘 Log2 그래프
![로그2무작위](https://user-images.githubusercontent.com/39906922/173868547-9ea57664-0db0-4914-a79c-bdaeb9fa5dd5.png)

따라서, 이번 과제에 사용할 데이터 집합은 Log2가 적용된 정렬 알고리즘들이다.

## 최적화 알고리즘
회귀식을 추정할 때, 사용할 알고리즘은 **유전 알고리즘**으로 선택하였다.

**유전 알고리즘**은 초기 세대의 해로부터 다음 세대를 생성해가며, 우수한 해를 선출하고, 마지막 세대에서 최적해 또는 최적해에 근접한 해를 선출하는 알고리즘이다.

유전 알고리즘의 수행 단계는 아래의 3단계로 나뉜다.

**1. 선택 연산**

**2. 교차 연산**

**3. 돌연변이 연산**  

첫 번째 선택 연산에서는, 현재 세대의 후보해 중 가장 우수한 후보해를 선택하는 연산으로, 무조건 최우수 후보해만 넣는 것이 아니라, 우수한 정도에 따라 가중치를 두어 선택될 확률을 조정하여 선택하는 방식이다.

두 번째 교차 연산에서는, 선택 연산에서 선택된 후보해들끼리 일련의 연산을 통해 새로운 후보해를 탄생시키는 연산이다.

세 번째 돌연변이 연산에서는, 교차 연산을 통해 탄생한 새로운 후보해를 아주 작은 확률이 일부 변형시키는 연산이다.   
돌연변이 연산은 후보해의 적합도를 오히려 낮추는 경우도 있는데, 다음 세대에 돌연변이가 이루어진 후보해와 다른 후보해의 교차 연산 후 탄생한 후보해가 우수한 후보해임을 기대하는 것에 의의를 두는 연산이다.


## 구현(JAVA)
먼저 데이터 집합을 실수형 배열로 옮겨야 하는데, 여기선 버블 정렬을 선택하였다.
```
double[] bubble = {0, -8.0, -6.3, -6.1, -5.8, -5.0, -2.8, -0.8, 1.3, 2.6, 3.1, 3.3, 4.2, 5.7, 7.6, 10.2, 12.7, 14.5, 16.6, 18.6, 20.6};
```

---
그 후 ax + b 형태의 방정식을 나타내기 위해, Problem 인터페이스를 생성하였다.
```
public interface Problem {
    double fit(double x, double a, double b);
}
```
---

선택한 후보해 a와 b를 대입해 에러율을 구하는 함수를 구현하였다.
```
// 후보해로 선정된 a와 b를 ax + b 식에 대입해 에러율을 구하는 함수
    private double errorRate(double candidatesA, double candidatesB, double[] sortingAlgorithm, Problem p){
        int sort_length = sortingAlgorithm.length;
        double errorSum = 0;

        for(int i = 0; i < sort_length; i++) {
            double result = p.fit(i, candidatesA, candidatesB);
            errorSum += Math.abs(sortingAlgorithm[i] - result); // 정렬 알고리즘의 i번째 결과와 ax+b의 결과를 서로 빼 절대값 연산을 취하여 에러 값의 합을 산출하였다.
        }

        return errorSum / sort_length; // 총 더해진 에러 값의 평균을 구하면, 선택된 a, b의 에러율이 나오게 된다.
    }
```


